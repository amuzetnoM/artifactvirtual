import { Request, Response } from 'express';
import { z } from 'zod';
import mongoose from 'mongoose';
import DocumentModel, { IDocument } from '../models/document.model';
import VersionModel from '../models/version.model';

// Validation schemas
const createDocumentSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.string(),
  tags: z.array(z.string().trim().toLowerCase().max(50)).optional(),
  isPublic: z.boolean().optional(),
  metadata: z.object({
    author: z.string().optional(),
    description: z.string().max(500).optional(),
    keywords: z.array(z.string()).optional(),
    canonicalUrl: z.string().url().optional().nullable()
  }).optional()
});

const updateDocumentSchema = z.object({
  title: z.string().min(1).max(200).optional(),
  content: z.string().optional(),
  tags: z.array(z.string().trim().toLowerCase().max(50)).optional(),
  isPublic: z.boolean().optional(),
  metadata: z.object({
    author: z.string().optional(),
    description: z.string().max(500).optional(),
    keywords: z.array(z.string()).optional(),
    canonicalUrl: z.string().url().optional().nullable()
  }).optional()
});

// Calculate differences between two document contents for versioning
function calculateChanges(oldContent: string, newContent: string) {
  const oldLines = oldContent.split('\n');
  const newLines = newContent.split('\n');
  
  let additions = 0;
  let deletions = 0;
  
  // Simple diff algorithm (can be enhanced with a proper diff library)
  if (oldLines.length > newLines.length) {
    deletions += oldLines.length - newLines.length;
  } else {
    additions += newLines.length - oldLines.length;
  }
  
  // Count character changes
  const oldChars = oldContent.length;
  const newChars = newContent.length;
  
  if (newChars > oldChars) {
    additions += Math.floor((newChars - oldChars) / 10); // Rough estimate
  } else {
    deletions += Math.floor((oldChars - newChars) / 10); // Rough estimate
  }
  
  return {
    additions,
    deletions
  };
}

// Document controllers
export const getAllDocuments = async (req: Request, res: Response) => {
  try {
    if (!req.userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    // Pagination parameters
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 10;
    const skip = (page - 1) * limit;
    
    // Filter parameters
    const tag = req.query.tag as string;
    const query: any = { ownerId: req.userId };
    
    if (tag) {
      query.tags = tag;
    }
    
    // Get total count for pagination
    const totalDocuments = await DocumentModel.countDocuments(query);
    
    // Get documents with pagination
    const documents = await DocumentModel.find(query)
      .sort({ updatedAt: -1 })
      .skip(skip)
      .limit(limit)
      .select('title tags contentPreview isPublic isPublished createdAt updatedAt');
    
    res.json({
      documents,
      pagination: {
        total: totalDocuments,
        page,
        limit,
        pages: Math.ceil(totalDocuments / limit)
      }
    });
  } catch (error) {
    console.error('Get documents error:', error);
    res.status(500).json({ error: 'An error occurred fetching documents' });
  }
};

export const getDocumentById = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'Invalid document ID' });
    }
    
    const document = await DocumentModel.findById(id);
    
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    // Check ownership or permissions
    if (!document.isPublic && document.ownerId.toString() !== req.userId) {
      // Check if user is a collaborator
      const isCollaborator = document.collaborators?.some(
        (collab) => collab.userId.toString() === req.userId
      );
      
      if (!isCollaborator) {
        return res.status(403).json({ error: 'Access denied' });
      }
    }
    
    res.json(document);
  } catch (error) {
    console.error('Get document error:', error);
    res.status(500).json({ error: 'An error occurred fetching the document' });
  }
};

export const createDocument = async (req: Request, res: Response) => {
  try {
    if (!req.userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const validatedData = createDocumentSchema.parse(req.body);
    
    const document = new DocumentModel({
      ...validatedData,
      ownerId: req.userId,
      contentPreview: '', // Will be generated by pre-save hook
      version: 1
    });
    
    const savedDocument = await document.save();
    
    // Create initial version
    const version = new VersionModel({
      documentId: savedDocument._id,
      userId: req.userId,
      content: savedDocument.content,
      version: 1,
      changes: {
        additions: savedDocument.content.length,
        deletions: 0
      }
    });
    
    await version.save();
    
    res.status(201).json(savedDocument);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation error',
        details: error.errors
      });
    }
    
    console.error('Create document error:', error);
    res.status(500).json({ error: 'An error occurred creating document' });
  }
};

export const updateDocument = async (req: Request, res: Response) => {
  try {
    if (!req.userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const { id } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'Invalid document ID' });
    }
    
    const validatedData = updateDocumentSchema.parse(req.body);
    
    // Find existing document
    const existingDocument = await DocumentModel.findById(id);
    
    if (!existingDocument) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    // Check ownership or edit permissions
    if (existingDocument.ownerId.toString() !== req.userId) {
      // Check if user is a collaborator with edit permission
      const isEditor = existingDocument.collaborators?.some(
        (collab) => collab.userId.toString() === req.userId && 
          (collab.role === 'editor' || collab.role === 'admin')
      );
      
      if (!isEditor) {
        return res.status(403).json({ error: 'Access denied' });
      }
    }
    
    // If content is updated, create a new version
    if (validatedData.content && validatedData.content !== existingDocument.content) {
      const changes = calculateChanges(existingDocument.content, validatedData.content);
      
      // Increment document version
      const newVersion = existingDocument.version + 1;
      validatedData.version = newVersion;
      
      // Create a new version document
      const version = new VersionModel({
        documentId: id,
        userId: req.userId,
        content: validatedData.content,
        version: newVersion,
        changes
      });
      
      await version.save();
    }
    
    // Update the document
    const updatedDocument = await DocumentModel.findByIdAndUpdate(
      id,
      { $set: validatedData },
      { new: true, runValidators: true }
    );
    
    res.json(updatedDocument);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation error',
        details: error.errors
      });
    }
    
    console.error('Update document error:', error);
    res.status(500).json({ error: 'An error occurred updating document' });
  }
};

export const deleteDocument = async (req: Request, res: Response) => {
  try {
    if (!req.userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    const { id } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'Invalid document ID' });
    }
    
    // Find the document
    const document = await DocumentModel.findById(id);
    
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    // Check ownership or admin permissions
    if (document.ownerId.toString() !== req.userId) {
      // Check if user is a collaborator with admin permission
      const isAdmin = document.collaborators?.some(
        (collab) => collab.userId.toString() === req.userId && collab.role === 'admin'
      );
      
      if (!isAdmin) {
        return res.status(403).json({ error: 'Access denied' });
      }
    }
    
    // Delete the document
    await DocumentModel.findByIdAndDelete(id);
    
    // Delete all versions of the document
    await VersionModel.deleteMany({ documentId: id });
    
    // In a production app, should also delete comments and other related data
    
    res.status(200).json({ message: 'Document deleted successfully' });
  } catch (error) {
    console.error('Delete document error:', error);
    res.status(500).json({ error: 'An error occurred deleting document' });
  }
};

export const getDocumentVersions = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: 'Invalid document ID' });
    }
    
    // Check document exists and user has access
    const document = await DocumentModel.findById(id);
    
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    // Check permissions
    if (!document.isPublic && document.ownerId.toString() !== req.userId) {
      const isCollaborator = document.collaborators?.some(
        (collab) => collab.userId.toString() === req.userId
      );
      
      if (!isCollaborator) {
        return res.status(403).json({ error: 'Access denied' });
      }
    }
    
    // Get versions
    const versions = await VersionModel.find({ documentId: id })
      .select('-content') // Don't include full content in list
      .sort({ version: -1 })
      .populate('userId', 'username displayName avatarUrl');
    
    res.json(versions);
  } catch (error) {
    console.error('Get versions error:', error);
    res.status(500).json({ error: 'An error occurred fetching document versions' });
  }
};

export const getDocumentVersion = async (req: Request, res: Response) => {
  try {
    const { id, versionId } = req.params;
    
    if (!mongoose.Types.ObjectId.isValid(id) || !mongoose.Types.ObjectId.isValid(versionId)) {
      return res.status(400).json({ error: 'Invalid ID' });
    }
    
    // Check document exists and user has access
    const document = await DocumentModel.findById(id);
    
    if (!document) {
      return res.status(404).json({ error: 'Document not found' });
    }
    
    // Check permissions
    if (!document.isPublic && document.ownerId.toString() !== req.userId) {
      const isCollaborator = document.collaborators?.some(
        (collab) => collab.userId.toString() === req.userId
      );
      
      if (!isCollaborator) {
        return res.status(403).json({ error: 'Access denied' });
      }
    }
    
    // Get specific version
    const version = await VersionModel.findOne({
      _id: versionId,
      documentId: id
    }).populate('userId', 'username displayName avatarUrl');
    
    if (!version) {
      return res.status(404).json({ error: 'Version not found' });
    }
    
    res.json(version);
  } catch (error) {
    console.error('Get version error:', error);
    res.status(500).json({ error: 'An error occurred fetching document version' });
  }
};